# Copyright Materialize, Inc. and contributors. All rights reserved.
#
# Use of this software is governed by the Business Source License
# included in the LICENSE file at the root of this repository.
#
# As of the Change Date specified in that file, in accordance with
# the Business Source License, use of this software will be governed
# by the Apache License, Version 2.0.

# Ensure attribution sources function (are created, dropped appropriately)

mode cockroach

reset-server

# VIEW + INDEX

statement ok
CREATE TABLE t(x INT NOT NULL, y INT, z TEXT);

statement ok
CREATE VIEW v AS
  SELECT t1.x AS x, t1.z AS z1, t2.z AS z2
  FROM t AS t1, t AS t2
  WHERE t1.x = t2.y;

statement ok
CREATE INDEX v_idx_x ON v(x);

# let the introspection sources update
statement ok
SELECT mz_unsafe.mz_sleep(8)

query IT
SELECT id, global_id FROM mz_internal.mz_dataflow_global_ids ORDER BY id, global_id;
----
4  u2
4  u3

query TI
SELECT global_id, lir_id FROM mz_internal.mz_lir_mapping ORDER BY global_id, lir_id DESC;
----
u2  5
u2  4
u2  3
u2  2
u2  1
u3  7
u3  6

## attribution queries

# omitting sum(duration_ns) as duration, sum(count) as count
query TIIT
SELECT global_id, lir_id, parent_lir_id, REPEAT(' ', nesting * 2) || operator AS operator
    FROM           mz_internal.mz_lir_mapping mlm
         LEFT JOIN mz_introspection.mz_compute_operator_durations_histogram mcodh
         ON (mlm.operator_id_start <= mcodh.id AND mcodh.id < mlm.operator_id_end)
GROUP BY global_id, lir_id, operator, parent_lir_id, nesting
ORDER BY global_id, lir_id DESC;
----
u2  5  NULL  Join::Differential␠2␠»␠4
u2  4  5  ␠␠Arrange␠3
u2  3  4  ␠␠␠␠Get::Collection␠u1
u2  2  5  ␠␠Arrange␠1
u2  1  2  ␠␠␠␠Get::Collection␠u1
u3  7  NULL  Arrange␠6
u3  6  7  ␠␠Get::PassArrangements␠u2

# omitting pg_size_pretty(sum(size)) as size
query TIIT
SELECT global_id, lir_id, parent_lir_id, repeat(' ', nesting * 2) || operator AS operator
    FROM           mz_internal.mz_lir_mapping mlm
         LEFT JOIN mz_introspection.mz_arrangement_sizes mas
         ON (mlm.operator_id_start <= mas.operator_id AND mas.operator_id < mlm.operator_id_end)
GROUP BY global_id, lir_id, operator, parent_lir_id, nesting
ORDER BY global_id, lir_id DESC;
----
u2  5  NULL  Join::Differential␠2␠»␠4
u2  4  5  ␠␠Arrange␠3
u2  3  4  ␠␠␠␠Get::Collection␠u1
u2  2  5  ␠␠Arrange␠1
u2  1  2  ␠␠␠␠Get::Collection␠u1
u3  7  NULL  Arrange␠6
u3  6  7  ␠␠Get::PassArrangements␠u2

statement ok
DROP TABLE t CASCADE;

# we need the dataflow to actually drop to see the updates
statement ok
SELECT mz_unsafe.mz_sleep(3)

query I
SELECT COUNT(*) FROM mz_internal.mz_dataflow_global_ids;
----
0

query I
SELECT COUNT(*) FROM mz_internal.mz_lir_mapping;
----
0

# MATERIALIZED VIEW

statement ok
CREATE TABLE u(x INT NOT NULL, y INT, z TEXT);

statement ok
CREATE MATERIALIZED VIEW w AS
  SELECT t1.x AS x, t1.z AS z1, t2.z AS z2
  FROM u AS t1, u AS t2
  WHERE t1.x = t2.y;

# let the introspection sources update
statement ok
SELECT mz_unsafe.mz_sleep(8)

query IT
SELECT id, global_id FROM mz_internal.mz_dataflow_global_ids ORDER BY id, global_id;
----
9  t44


query TI
SELECT global_id, lir_id FROM mz_internal.mz_lir_mapping ORDER BY global_id, lir_id DESC;
----
t44  5
t44  4
t44  3
t44  2
t44  1

## attribution queries

# omitting sum(duration_ns) as duration, sum(count) as count
query TIIT
SELECT global_id, lir_id, parent_lir_id, REPEAT(' ', nesting * 2) || operator AS operator
    FROM           mz_internal.mz_lir_mapping mlm
         LEFT JOIN mz_introspection.mz_compute_operator_durations_histogram mcodh
         ON (mlm.operator_id_start <= mcodh.id AND mcodh.id < mlm.operator_id_end)
GROUP BY global_id, lir_id, operator, parent_lir_id, nesting
ORDER BY global_id, lir_id DESC;
----
t44  5  NULL  Join::Differential␠2␠»␠4
t44  4  5  ␠␠Arrange␠3
t44  3  4  ␠␠␠␠Get::Collection␠u4
t44  2  5  ␠␠Arrange␠1
t44  1  2  ␠␠␠␠Get::Collection␠u4

# omitting pg_size_pretty(sum(size)) as size
query TIIT
SELECT global_id, lir_id, parent_lir_id, REPEAT(' ', nesting * 2) || operator AS operator
    FROM           mz_internal.mz_lir_mapping mlm
         LEFT JOIN mz_introspection.mz_arrangement_sizes mas
         ON (mlm.operator_id_start <= mas.operator_id AND mas.operator_id < mlm.operator_id_end)
GROUP BY global_id, lir_id, operator, parent_lir_id, nesting
ORDER BY global_id, lir_id DESC;
----
t44  5  NULL  Join::Differential␠2␠»␠4
t44  4  5  ␠␠Arrange␠3
t44  3  4  ␠␠␠␠Get::Collection␠u4
t44  2  5  ␠␠Arrange␠1
t44  1  2  ␠␠␠␠Get::Collection␠u4

statement ok
DROP TABLE u CASCADE;

# we need the dataflow to actually drop to see the updates
statement ok
SELECT mz_unsafe.mz_sleep(3)

query I
SELECT COUNT(*) FROM mz_internal.mz_dataflow_global_ids;
----
0

query I
SELECT COUNT(*) FROM mz_internal.mz_lir_mapping;
----
0

# checking in on bindings

statement ok
CREATE TABLE Person (
    creationDate timestamp with time zone NOT NULL,
    id bigint,
    firstName text NOT NULL,
    lastName text NOT NULL,
    gender text NOT NULL,
    birthday date NOT NULL,
    locationIP text NOT NULL,
    browserUsed text NOT NULL,
    LocationCityId bigint NOT NULL,
    speaks text NOT NULL,
    email text NOT NULL
)

statement ok
CREATE INDEX Person_id ON Person (id)

statement ok
CREATE INDEX Person_LocationCityId ON Person (LocationCityId)

statement ok
CREATE TABLE Person_knows_Person (
    creationDate timestamp with time zone NOT NULL,
    Person1id bigint NOT NULL,
    Person2id bigint NOT NULL
)

statement ok
CREATE INDEX Person_knows_Person_Person1id ON Person_knows_Person (Person1id)

statement ok
CREATE INDEX Person_knows_Person_Person2id ON person_knows_person (Person2id)

statement ok
CREATE INDEX Person_knows_Person_Person1id_Person2id ON Person_knows_Person (Person1id, Person2id)

statement ok
CREATE TABLE Post (
    creationDate timestamp with time zone NOT NULL,
    id bigint NOT NULL,
    imageFile text,
    locationIP text NOT NULL,
    browserUsed text NOT NULL,
    language text,
    content text,
    length int NOT NULL,
    CreatorPersonId bigint NOT NULL,
    ContainerForumId bigint NOT NULL,
    LocationCountryId bigint NOT NULL
)

statement ok
CREATE INDEX Post_id ON Post (id)

statement ok
CREATE TABLE Comment (
    creationDate timestamp with time zone NOT NULL,
    id bigint NOT NULL,
    locationIP text NOT NULL,
    browserUsed text NOT NULL,
    content text NOT NULL,
    length int NOT NULL,
    CreatorPersonId bigint NOT NULL,
    LocationCountryId bigint NOT NULL,
    ParentPostId bigint,
    ParentCommentId bigint
)

statement ok
CREATE INDEX Comment_id ON Comment (id)

statement ok
CREATE OR REPLACE MATERIALIZED VIEW Message AS
WITH MUTUALLY RECURSIVE
  -- compute the transitive closure (with root information) using minimnal info
  roots (MessageId bigint, RootPostId bigint, RootPostLanguage text, ContainerForumId bigint, ParentMessageId bigint) AS
    (      SELECT id AS MessageId, id AS RootPostId, language AS RootPostLanguage, ContainerForumId, NULL::bigint AS ParentMessageId FROM Post
     UNION SELECT
              Comment.id AS MessageId,
         ParentPostId AS RootPostId,
         language AS RootPostLanguage,
         Post.ContainerForumId AS ContainerForumId,
         ParentPostId AS ParentMessageId
           FROM Comment
       JOIN Post
       ON Comment.ParentPostId = Post.id),
  ms (MessageId bigint, RootPostId bigint, RootPostLanguage text, ContainerForumId bigint, ParentMessageId bigint) AS
    (      SELECT *
           FROM roots
     UNION SELECT
              Comment.id AS MessageId,
         ms.RootPostId AS RootPostId,
         ms.RootPostLanguage AS RootPostLanguage,
         ms.ContainerForumId AS ContainerForumId,
         ParentCommentId AS ParentMessageId
           FROM Comment
       JOIN ms
       ON ParentCommentId = ms.MessageId)
  -- now do the late materialization
  (     SELECT
          creationDate,
          id AS MessageId,
          id AS RootPostId,
          language AS RootPostLanguage,
          content,
          imageFile,
          locationIP,
          browserUsed,
          length,
          CreatorPersonId,
          ContainerForumId,
          LocationCountryId,
          NULL::bigint AS ParentMessageId
        FROM Post
  UNION (SELECT
          Comment.creationDate AS creationDate,
          Comment.id AS MessageId,
          ms.RootPostId AS RootPostId,
          ms.RootPostLanguage AS RootPostLanguage,
          Comment.content AS content,
          NULL::text AS imageFile,
          Comment.locationIP AS locationIP,
          Comment.browserUsed AS browserUsed,
          Comment.length AS length,
          Comment.CreatorPersonId AS CreatorPersonId,
          ms.ContainerForumId AS ContainerForumId,
          Comment.LocationCountryId AS LocationCityId,
          ms.ParentMessageId AS ParentMessageId
    FROM Comment
    JOIN ms
    ON Comment.id = ms.MessageId))

statement ok
CREATE INDEX Message_MessageId ON Message (MessageId)

statement ok
CREATE INDEX Message_ParentMessageId ON Message (ParentMessageId)

statement ok
CREATE INDEX Message_CreatorPersonId ON Message (CreatorPersonId)

statement ok
CREATE VIEW PathQ19 AS
WITH
  -- asymmetrize...
  knows_asymmetric AS (
    SELECT person1id, person2id
      FROM Person_knows_person
     WHERE person1id < person2id
  ),
  -- compute interaction scores (no interactions means we ignore that 'knows' relationship)
  weights(src, dst, w) AS (
    SELECT
        person1id AS src,
        person2id AS dst,
        greatest(round(40 - sqrt(count(*)))::bigint, 1) AS w
    FROM Message m1,
         Message m2,
         knows_asymmetric pp
    WHERE pp.person1id = least(m1.creatorpersonid, m2.creatorpersonid)
      AND pp.person2id = greatest(m1.creatorpersonid, m2.creatorpersonid)
      AND m1.parentmessageid = m2.messageid
      AND m1.creatorpersonid <> m2.creatorpersonid
 GROUP BY src, dst
)
-- resymmetrize
SELECT src, dst, w FROM weights
UNION ALL
SELECT dst, src, w FROM weights;

statement ok
CREATE INDEX PathQ19_src ON PathQ19 (src);

statement ok
CREATE VIEW ldbc_q19 AS
WITH MUTUALLY RECURSIVE
  -- Source and destination identifiers, which do not evolve recursively.
  srcs (f bigint) AS (SELECT id FROM Person WHERE locationcityid = 655::bigint),
  dsts (t bigint) AS (SELECT id FROM Person WHERE locationcityid = 1138::bigint),
  -- Only work off of nodes not more than half a viable path.
  active_forward(src bigint, dst bigint, w double precision) AS (
    SELECT * FROM forward WHERE coalesce (w < (SELECT w/2 FROM shortest), true)
  ),
  forward (src bigint, dst bigint, w double precision) AS (
    SELECT DISTINCT ON (src, dst) src, dst, w
    FROM (
      SELECT f as src, f as dst, 0.0 as w FROM srcs
      UNION ALL
      SELECT f.src, p.dst, f.w + p.w
      FROM active_forward f, PathQ19 p
      WHERE f.dst = p.src
    )
    ORDER BY src, dst, w
  ),
  -- Only work off of nodes not more than half a viable path.
  active_reverse(src bigint, dst bigint, w double precision) AS (
    SELECT * FROM reverse WHERE coalesce (w < (SELECT w/2 FROM shortest), true)
  ),
  reverse (src bigint, dst bigint, w double precision) AS (
    SELECT DISTINCT ON (src, dst) src, dst, w
    FROM (
      SELECT t as src, t as dst, 0.0 as w FROM dsts
      UNION ALL
      SELECT r.src, p.dst, r.w + p.w
      FROM active_reverse r, PathQ19 p
      WHERE r.dst = p.src
    )
    ORDER BY src, dst, w
  ),
  -- Once we find a path from `f` to `t` it appears here.
  paths (f bigint, t bigint, w double precision) AS (
    SELECT l.src as f, r.src as t, min(l.w + r.w) AS w
    FROM forward l, reverse r
    WHERE l.dst = r.dst
    GROUP BY l.src, r.src
  ),
  shortest (w double precision) AS (
    SELECT min(w) FROM paths
  )
SELECT f, t, w
FROM paths
WHERE w = (SELECT MIN(w) FROM paths);

statement ok
CREATE INDEX ldbc_q19_idx ON ldbc_q19 (f);

statement ok
SELECT mz_unsafe.mz_sleep(2)

query TT
SELECT global_id, REPEAT(' ', nesting * 2) || operator AS operator
FROM mz_internal.mz_lir_mapping mlm
ORDER BY global_id, lir_id DESC;
----
t69  Returning␠Reduce::Distinct␠19
t69  ␠␠Union␠14␠18
t69  ␠␠␠␠Join::Differential␠15␠»␠17
t69  ␠␠␠␠␠␠Arrange␠16
t69  ␠␠␠␠␠␠␠␠Get::PassArrangements␠l0
t69  ␠␠␠␠␠␠Get::PassArrangements␠u15
t69  ␠␠␠␠Get::Arrangement␠u13
t69  With␠Recursive␠l0␠=␠Arrange␠12
t69  ␠␠Reduce::Distinct␠11
t69  ␠␠␠␠Union␠1␠5␠10
t69  ␠␠␠␠␠␠Join::Differential␠7␠»␠9
t69  ␠␠␠␠␠␠␠␠Arrange␠8
t69  ␠␠␠␠␠␠␠␠␠␠Get::Collection␠l0
t69  ␠␠␠␠␠␠␠␠Arrange␠6
t69  ␠␠␠␠␠␠␠␠␠␠Get::Arrangement␠u15
t69  ␠␠␠␠␠␠Join::Differential␠4␠»␠3
t69  ␠␠␠␠␠␠␠␠Get::PassArrangements␠u13
t69  ␠␠␠␠␠␠␠␠Arrange␠2
t69  ␠␠␠␠␠␠␠␠␠␠Get::Arrangement␠u15
t69  ␠␠␠␠␠␠Get::Arrangement␠u13
u10  Arrange␠1
u10  ␠␠Get::PassArrangements␠u9
u11  Arrange␠1
u11  ␠␠Get::PassArrangements␠u9
u12  Arrange␠1
u12  ␠␠Get::PassArrangements␠u9
u14  Arrange␠1
u14  ␠␠Get::PassArrangements␠u13
u16  Arrange␠1
u16  ␠␠Get::PassArrangements␠u15
u18  Arrange␠1
u18  ␠␠Get::PassArrangements␠u17
u19  Arrange␠1
u19  ␠␠Get::PassArrangements␠u17
u20  Arrange␠1
u20  ␠␠Get::PassArrangements␠u17
u21  Returning␠Union␠8␠9
u21  ␠␠Get::Collection␠l0
u21  ␠␠Get::PassArrangements␠l0
u21  With␠l0␠=␠MapFilterProject␠6
u21  ␠␠Reduce::Accumulable␠5
u21  ␠␠␠␠Join::Delta[2␠»␠3␠»␠4]␠[3␠»␠2␠»␠4]␠[4␠»␠2␠»␠3]␠
u21  ␠␠␠␠␠␠Get::PassArrangements␠u9
u21  ␠␠␠␠␠␠Get::PassArrangements␠u17
u21  ␠␠␠␠␠␠Arrange␠1
u21  ␠␠␠␠␠␠␠␠Get::Arrangement␠u17
u22  Arrange␠12
u22  ␠␠Get::PassArrangements␠u21
u23  Returning␠Join::Differential␠54␠»␠51
u23  ␠␠Arrange␠53
u23  ␠␠␠␠Reduce::Hierarchical␠52␠(buckets:␠268435456␠16777216␠1048576␠65536␠4096␠256␠16)
u23  ␠␠␠␠␠␠Get::Collection␠l5
u23  ␠␠Arrange␠50
u23  ␠␠␠␠Get::PassArrangements␠l5
u23  l7␠=␠Union␠43␠48
u23  ␠␠MapFilterProject␠47
u23  ␠␠␠␠Union␠45␠46␠(consolidates␠output)
u23  ␠␠␠␠␠␠Constant␠1␠rows
u23  ␠␠␠␠␠␠Negate␠44
u23  ␠␠␠␠␠␠␠␠Get::Arrangement␠l6
u23  ␠␠Get::PassArrangements␠l6
u23  l6␠=␠Arrange␠41
u23  ␠␠Reduce::Hierarchical␠40␠(buckets:␠268435456␠16777216␠1048576␠65536␠4096␠256␠16)
u23  ␠␠␠␠Get::Arrangement␠l5
u23  l5␠=␠Arrange␠38
u23  ␠␠Reduce::Hierarchical␠37␠(buckets:␠268435456␠16777216␠1048576␠65536␠4096␠256␠16)
u23  ␠␠␠␠Join::Differential␠34␠»␠36
u23  ␠␠␠␠␠␠Arrange␠35
u23  ␠␠␠␠␠␠␠␠Get::Collection␠l4
u23  ␠␠␠␠␠␠Arrange␠33
u23  ␠␠␠␠␠␠␠␠Get::Collection␠l3
u23  l4␠=␠TopK::Basic␠31
u23  ␠␠Union␠25␠30
u23  ␠␠␠␠Join::Delta[27␠»␠29␠»␠28]␠[28␠»␠27␠»␠29]␠[29␠»␠27␠»␠28]␠
u23  ␠␠␠␠␠␠Get::PassArrangements␠l1
u23  ␠␠␠␠␠␠Get::PassArrangements␠l2
u23  ␠␠␠␠␠␠Arrange␠26
u23  ␠␠␠␠␠␠␠␠Get::Collection␠l4
u23  ␠␠␠␠Join::Differential␠24␠»␠22
u23  ␠␠␠␠␠␠Arrange␠23
u23  ␠␠␠␠␠␠␠␠Constant␠1␠rows
u23  ␠␠␠␠␠␠Get::PassArrangements␠l0
u23  l3␠=␠TopK::Basic␠20
u23  ␠␠Union␠14␠19
u23  ␠␠␠␠Join::Delta[16␠»␠18␠»␠17]␠[17␠»␠16␠»␠18]␠[18␠»␠16␠»␠17]␠
u23  ␠␠␠␠␠␠Get::PassArrangements␠l1
u23  ␠␠␠␠␠␠Get::PassArrangements␠l2
u23  ␠␠␠␠␠␠Arrange␠15
u23  ␠␠␠␠␠␠␠␠Get::Collection␠l3
u23  ␠␠␠␠Join::Differential␠13␠»␠11
u23  ␠␠␠␠␠␠Arrange␠12
u23  ␠␠␠␠␠␠␠␠Constant␠1␠rows
u23  ␠␠␠␠␠␠Get::PassArrangements␠l0
u23  With␠Recursive␠l2␠=␠Arrange␠9
u23  ␠␠Union␠3␠8
u23  ␠␠␠␠MapFilterProject␠7
u23  ␠␠␠␠␠␠Union␠5␠6␠(consolidates␠output)
u23  ␠␠␠␠␠␠␠␠Constant␠1␠rows
u23  ␠␠␠␠␠␠␠␠Negate␠4
u23  ␠␠␠␠␠␠␠␠␠␠Get::Collection␠l7
u23  ␠␠␠␠Get::Collection␠l7
u23  l1␠=␠Get::PassArrangements␠u21
u23  With␠l0␠=␠Get::PassArrangements␠u6
u24  Arrange␠59
u24  ␠␠Get::PassArrangements␠u23
u7  Arrange␠1
u7  ␠␠Get::PassArrangements␠u6
u8  Arrange␠1
u8  ␠␠Get::PassArrangements␠u6

statement ok
DROP TABLE Person, Person_knows_Person CASCADE;

# ATTRIBUTING TOP K HINTS

statement ok
CREATE TABLE t(x INT NOT NULL, y INT, z TEXT);

statement ok
CREATE VIEW v2 AS SELECT DISTINCT ON(x, y) * FROM t ORDER BY x, y;

statement ok
CREATE INDEX v2_idx_x ON v2(x);

statement ok
SELECT mz_unsafe.mz_sleep(8)

query TIITIIIT
SELECT mlm.global_id AS global_id, lir_id, parent_lir_id, REPEAT(' ', nesting * 2) || operator AS operator, levels, to_cut, savings, hint
    FROM           mz_internal.mz_lir_mapping mlm
         JOIN      mz_introspection.mz_dataflow_global_ids mdgi
         ON (mlm.global_id = mdgi.global_id)
         LEFT JOIN mz_introspection.mz_expected_group_size_advice megsa
         ON (megsa.dataflow_id = mdgi.id AND
             mlm.operator_id_start <= megsa.region_id AND megsa.region_id < mlm.operator_id_end)
ORDER BY mlm.global_id, lir_id DESC;
----
t69  20  NULL  Returning␠Reduce::Distinct␠19  NULL  NULL  NULL  NULL
t69  19  20  ␠␠Union␠14␠18  NULL  NULL  NULL  NULL
t69  18  19  ␠␠␠␠Join::Differential␠15␠»␠17  NULL  NULL  NULL  NULL
t69  17  18  ␠␠␠␠␠␠Arrange␠16  NULL  NULL  NULL  NULL
t69  16  17  ␠␠␠␠␠␠␠␠Get::PassArrangements␠l0  NULL  NULL  NULL  NULL
t69  15  18  ␠␠␠␠␠␠Get::PassArrangements␠u15  NULL  NULL  NULL  NULL
t69  14  19  ␠␠␠␠Get::Arrangement␠u13  NULL  NULL  NULL  NULL
t69  13  NULL  With␠Recursive␠l0␠=␠Arrange␠12  NULL  NULL  NULL  NULL
t69  12  13  ␠␠Reduce::Distinct␠11  NULL  NULL  NULL  NULL
t69  11  12  ␠␠␠␠Union␠1␠5␠10  NULL  NULL  NULL  NULL
t69  10  11  ␠␠␠␠␠␠Join::Differential␠7␠»␠9  NULL  NULL  NULL  NULL
t69  9  10  ␠␠␠␠␠␠␠␠Arrange␠8  NULL  NULL  NULL  NULL
t69  8  9  ␠␠␠␠␠␠␠␠␠␠Get::Collection␠l0  NULL  NULL  NULL  NULL
t69  7  10  ␠␠␠␠␠␠␠␠Arrange␠6  NULL  NULL  NULL  NULL
t69  6  7  ␠␠␠␠␠␠␠␠␠␠Get::Arrangement␠u15  NULL  NULL  NULL  NULL
t69  5  11  ␠␠␠␠␠␠Join::Differential␠4␠»␠3  NULL  NULL  NULL  NULL
t69  4  5  ␠␠␠␠␠␠␠␠Get::PassArrangements␠u13  NULL  NULL  NULL  NULL
t69  3  5  ␠␠␠␠␠␠␠␠Arrange␠2  NULL  NULL  NULL  NULL
t69  2  3  ␠␠␠␠␠␠␠␠␠␠Get::Arrangement␠u15  NULL  NULL  NULL  NULL
t69  1  11  ␠␠␠␠␠␠Get::Arrangement␠u13  NULL  NULL  NULL  NULL
u14  2  NULL  Arrange␠1  NULL  NULL  NULL  NULL
u14  1  2  ␠␠Get::PassArrangements␠u13  NULL  NULL  NULL  NULL
u16  2  NULL  Arrange␠1  NULL  NULL  NULL  NULL
u16  1  2  ␠␠Get::PassArrangements␠u15  NULL  NULL  NULL  NULL
u18  2  NULL  Arrange␠1  NULL  NULL  NULL  NULL
u18  1  2  ␠␠Get::PassArrangements␠u17  NULL  NULL  NULL  NULL
u19  2  NULL  Arrange␠1  NULL  NULL  NULL  NULL
u19  1  2  ␠␠Get::PassArrangements␠u17  NULL  NULL  NULL  NULL
u20  2  NULL  Arrange␠1  NULL  NULL  NULL  NULL
u20  1  2  ␠␠Get::PassArrangements␠u17  NULL  NULL  NULL  NULL
u26  2  NULL  TopK::Basic␠1  8  7  3808  15.000
u26  1  2  ␠␠Get::PassArrangements␠u25  NULL  NULL  NULL  NULL
u27  4  NULL  Arrange␠3  NULL  NULL  NULL  NULL
u27  3  4  ␠␠Get::PassArrangements␠u26  NULL  NULL  NULL  NULL

# rebuild everything other stuff, make sure it all shows up as mappable objects

statement ok
CREATE VIEW v AS
  SELECT t1.x AS x, t1.z AS z1, t2.z AS z2
  FROM t AS t1, t AS t2
  WHERE t1.x = t2.y;

statement ok
CREATE INDEX v_idx_x ON v(x);

statement ok
CREATE TABLE u(x INT NOT NULL, y INT, z TEXT);

statement ok
CREATE MATERIALIZED VIEW w AS
  SELECT t1.x AS x, t1.z AS z1, t2.z AS z2
  FROM u AS t1, u AS t2
  WHERE t1.x = t2.y;

statement ok
SELECT mz_unsafe.mz_sleep(8)

query TTI rowsort
SELECT name, global_id, COUNT(lir_id)
FROM mz_introspection.mz_mappable_objects LEFT JOIN mz_introspection.mz_lir_mapping
USING (global_id)
GROUP BY name, global_id;
----
materialize.public.comment_id  u16  2
materialize.public.message  t69  20
materialize.public.message_creatorpersonid  u20  2
materialize.public.message_messageid  u18  2
materialize.public.message_parentmessageid  u19  2
materialize.public.post_id  u14  2
materialize.public.v2_idx_x  u26  2
materialize.public.v2_idx_x  u27  2
materialize.public.v_idx_x  u28  5
materialize.public.v_idx_x  u29  2
materialize.public.w  t82  5

# explain analyze SQL generate

query T multiline
EXPLAIN ANALYZE MEMORY FOR MATERIALIZED VIEW w AS SQL;
----
WITH
    summary_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mas.size) AS total_memory,
            sum(mas.records) AS total_records,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN sum(mas.size) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_memory,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN
                                sum(mas.records) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    )
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    pg_size_pretty(sm.total_memory) AS total_memory,
    sm.total_records AS total_records
FROM
    mz_introspection.mz_lir_mapping AS mlm
        LEFT JOIN summary_memory AS sm USING(lir_id)
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.w'
ORDER BY mlm.lir_id DESC;
EOF

query T multiline
EXPLAIN ANALYZE CPU FOR MATERIALIZED VIEW w AS SQL;
----
WITH
    summary_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mse.elapsed_ns) AS total_ns,
            CASE
                    WHEN count(DISTINCT mse.worker_id) <> 0
                            THEN
                                sum(mse.elapsed_ns)
                                / count(DISTINCT mse.worker_id)
                        ELSE NULL
                END
                AS avg_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    )
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    sc.total_ns / 1000 * '1 microsecond'::interval AS total_elapsed
FROM
    mz_introspection.mz_lir_mapping AS mlm
        LEFT JOIN summary_cpu AS sc USING(lir_id)
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.w'
ORDER BY mlm.lir_id DESC;
EOF

query T multiline
EXPLAIN ANALYZE MEMORY, CPU FOR MATERIALIZED VIEW w AS SQL;
----
WITH
    summary_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mas.size) AS total_memory,
            sum(mas.records) AS total_records,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN sum(mas.size) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_memory,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN
                                sum(mas.records) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    summary_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mse.elapsed_ns) AS total_ns,
            CASE
                    WHEN count(DISTINCT mse.worker_id) <> 0
                            THEN
                                sum(mse.elapsed_ns)
                                / count(DISTINCT mse.worker_id)
                        ELSE NULL
                END
                AS avg_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    )
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    pg_size_pretty(sm.total_memory) AS total_memory,
    sm.total_records AS total_records,
    sc.total_ns / 1000 * '1 microsecond'::interval AS total_elapsed
FROM
    mz_introspection.mz_lir_mapping AS mlm
        LEFT JOIN summary_memory AS sm USING(lir_id)
        LEFT JOIN summary_cpu AS sc USING(lir_id)
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.w'
ORDER BY mlm.lir_id DESC;
EOF

query T multiline
EXPLAIN ANALYZE MEMORY, CPU WITH SKEW FOR MATERIALIZED VIEW w AS SQL;
----
WITH
    summary_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mas.size) AS total_memory,
            sum(mas.records) AS total_records,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN sum(mas.size) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_memory,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN
                                sum(mas.records) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    per_worker_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            mas.worker_id AS worker_id,
            sum(mas.size) AS worker_memory,
            sum(mas.records) AS worker_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id, mas.worker_id
    ),
    summary_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mse.elapsed_ns) AS total_ns,
            CASE
                    WHEN count(DISTINCT mse.worker_id) <> 0
                            THEN
                                sum(mse.elapsed_ns)
                                / count(DISTINCT mse.worker_id)
                        ELSE NULL
                END
                AS avg_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    per_worker_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            mse.worker_id AS worker_id,
            sum(mse.elapsed_ns) AS worker_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id, mse.worker_id
    )
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    pwm.worker_id AS worker_id,
    CASE
            WHEN pwm.worker_id IS NOT NULL AND sm.avg_memory <> 0
                    THEN round(pwm.worker_memory / sm.avg_memory, 2)
                ELSE NULL
        END
        AS memory_ratio,
    pg_size_pretty(pwm.worker_memory) AS worker_memory,
    pg_size_pretty(sm.avg_memory) AS avg_memory,
    pg_size_pretty(sm.total_memory) AS total_memory,
    CASE
            WHEN pwm.worker_id IS NOT NULL AND sm.avg_records <> 0
                    THEN round(pwm.worker_records / sm.avg_records, 2)
                ELSE NULL
        END
        AS records_ratio,
    pwm.worker_records AS worker_records,
    sm.avg_records AS avg_records,
    sm.total_records AS total_records,
    CASE
            WHEN pwc.worker_id IS NOT NULL AND sc.avg_ns <> 0
                    THEN round(pwc.worker_ns / sc.avg_ns, 2)
                ELSE NULL
        END
        AS cpu_ratio,
    pwc.worker_ns / 1000 * '1 microsecond'::interval AS worker_elapsed,
    sc.avg_ns / 1000 * '1 microsecond'::interval AS avg_elapsed,
    sc.total_ns / 1000 * '1 microsecond'::interval AS total_elapsed
FROM
    mz_introspection.mz_lir_mapping AS mlm
        LEFT JOIN summary_memory AS sm USING(lir_id)
        LEFT JOIN per_worker_memory AS pwm USING(lir_id)
        LEFT JOIN summary_cpu AS sc USING(lir_id)
        LEFT JOIN per_worker_cpu AS pwc USING(lir_id)
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.w' AND pwc.worker_id = pwm.worker_id
ORDER BY mlm.lir_id DESC, worker_id;
EOF

query T multiline
EXPLAIN ANALYZE CPU, MEMORY WITH SKEW FOR MATERIALIZED VIEW w AS SQL;
----
WITH
    summary_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mse.elapsed_ns) AS total_ns,
            CASE
                    WHEN count(DISTINCT mse.worker_id) <> 0
                            THEN
                                sum(mse.elapsed_ns)
                                / count(DISTINCT mse.worker_id)
                        ELSE NULL
                END
                AS avg_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    per_worker_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            mse.worker_id AS worker_id,
            sum(mse.elapsed_ns) AS worker_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id, mse.worker_id
    ),
    summary_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mas.size) AS total_memory,
            sum(mas.records) AS total_records,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN sum(mas.size) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_memory,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN
                                sum(mas.records) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    per_worker_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            mas.worker_id AS worker_id,
            sum(mas.size) AS worker_memory,
            sum(mas.records) AS worker_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id, mas.worker_id
    )
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    pwc.worker_id AS worker_id,
    CASE
            WHEN pwc.worker_id IS NOT NULL AND sc.avg_ns <> 0
                    THEN round(pwc.worker_ns / sc.avg_ns, 2)
                ELSE NULL
        END
        AS cpu_ratio,
    pwc.worker_ns / 1000 * '1 microsecond'::interval AS worker_elapsed,
    sc.avg_ns / 1000 * '1 microsecond'::interval AS avg_elapsed,
    sc.total_ns / 1000 * '1 microsecond'::interval AS total_elapsed,
    CASE
            WHEN pwm.worker_id IS NOT NULL AND sm.avg_memory <> 0
                    THEN round(pwm.worker_memory / sm.avg_memory, 2)
                ELSE NULL
        END
        AS memory_ratio,
    pg_size_pretty(pwm.worker_memory) AS worker_memory,
    pg_size_pretty(sm.avg_memory) AS avg_memory,
    pg_size_pretty(sm.total_memory) AS total_memory,
    CASE
            WHEN pwm.worker_id IS NOT NULL AND sm.avg_records <> 0
                    THEN round(pwm.worker_records / sm.avg_records, 2)
                ELSE NULL
        END
        AS records_ratio,
    pwm.worker_records AS worker_records,
    sm.avg_records AS avg_records,
    sm.total_records AS total_records
FROM
    mz_introspection.mz_lir_mapping AS mlm
        LEFT JOIN summary_cpu AS sc USING(lir_id)
        LEFT JOIN per_worker_cpu AS pwc USING(lir_id)
        LEFT JOIN summary_memory AS sm USING(lir_id)
        LEFT JOIN per_worker_memory AS pwm USING(lir_id)
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.w' AND pwm.worker_id = pwc.worker_id
ORDER BY mlm.lir_id DESC, worker_id;
EOF

# we can actually look at real hints here, because it'll be stable
query TIIIT
EXPLAIN ANALYZE HINTS FOR INDEX v2_idx_x;
----
Arrange␠3  NULL  NULL  NULL  NULL
␠␠Get::PassArrangements␠u26  NULL  NULL  NULL  NULL
TopK::Basic␠1  8  7  15  3808␠bytes
␠␠Get::PassArrangements␠u25  NULL  NULL  NULL  NULL

query T multiline
EXPLAIN ANALYZE HINTS FOR INDEX v2_idx_x AS SQL;
----
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    megsa.levels AS levels,
    megsa.to_cut AS to_cut,
    megsa.hint AS hint,
    pg_size_pretty(savings) AS savings
FROM
    mz_introspection.mz_lir_mapping AS mlm
        JOIN
            mz_introspection.mz_dataflow_global_ids AS mdgi
            ON (mlm.global_id = mdgi.global_id)
        LEFT JOIN
            mz_introspection.mz_expected_group_size_advice AS megsa
            ON
                (
                    megsa.dataflow_id = mdgi.id
                        AND
                    mlm.operator_id_start <= megsa.region_id
                        AND
                    megsa.region_id < mlm.operator_id_end
                )
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.v2_idx_x'
ORDER BY mlm.lir_id DESC;
EOF

query T multiline
EXPLAIN ANALYZE CPU, MEMORY WITH SKEW FOR INDEX v2_idx_x AS SQL;
----
WITH
    summary_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mse.elapsed_ns) AS total_ns,
            CASE
                    WHEN count(DISTINCT mse.worker_id) <> 0
                            THEN
                                sum(mse.elapsed_ns)
                                / count(DISTINCT mse.worker_id)
                        ELSE NULL
                END
                AS avg_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    per_worker_cpu AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            mse.worker_id AS worker_id,
            sum(mse.elapsed_ns) AS worker_ns
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_scheduling_elapsed_per_worker AS mse
                    ON
                        (
                            mlm.operator_id_start <= mse.id
                                AND
                            mse.id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id, mse.worker_id
    ),
    summary_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            sum(mas.size) AS total_memory,
            sum(mas.records) AS total_records,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN sum(mas.size) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_memory,
            CASE
                    WHEN count(DISTINCT mas.worker_id) <> 0
                            THEN
                                sum(mas.records) / count(DISTINCT mas.worker_id)
                        ELSE NULL
                END
                AS avg_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id
    ),
    per_worker_memory AS
    (
        SELECT
            mlm.lir_id AS lir_id,
            mas.worker_id AS worker_id,
            sum(mas.size) AS worker_memory,
            sum(mas.records) AS worker_records
        FROM
            mz_introspection.mz_lir_mapping AS mlm
                JOIN
                    mz_introspection.mz_arrangement_sizes_per_worker AS mas
                    ON
                        (
                            mlm.operator_id_start <= mas.operator_id
                                AND
                            mas.operator_id < mlm.operator_id_end
                        )
        GROUP BY mlm.lir_id, mas.worker_id
    )
SELECT
    repeat(' ', nesting * 2) || operator AS operator,
    pwc.worker_id AS worker_id,
    CASE
            WHEN pwc.worker_id IS NOT NULL AND sc.avg_ns <> 0
                    THEN round(pwc.worker_ns / sc.avg_ns, 2)
                ELSE NULL
        END
        AS cpu_ratio,
    pwc.worker_ns / 1000 * '1 microsecond'::interval AS worker_elapsed,
    sc.avg_ns / 1000 * '1 microsecond'::interval AS avg_elapsed,
    sc.total_ns / 1000 * '1 microsecond'::interval AS total_elapsed,
    CASE
            WHEN pwm.worker_id IS NOT NULL AND sm.avg_memory <> 0
                    THEN round(pwm.worker_memory / sm.avg_memory, 2)
                ELSE NULL
        END
        AS memory_ratio,
    pg_size_pretty(pwm.worker_memory) AS worker_memory,
    pg_size_pretty(sm.avg_memory) AS avg_memory,
    pg_size_pretty(sm.total_memory) AS total_memory,
    CASE
            WHEN pwm.worker_id IS NOT NULL AND sm.avg_records <> 0
                    THEN round(pwm.worker_records / sm.avg_records, 2)
                ELSE NULL
        END
        AS records_ratio,
    pwm.worker_records AS worker_records,
    sm.avg_records AS avg_records,
    sm.total_records AS total_records
FROM
    mz_introspection.mz_lir_mapping AS mlm
        LEFT JOIN summary_cpu AS sc USING(lir_id)
        LEFT JOIN per_worker_cpu AS pwc USING(lir_id)
        LEFT JOIN summary_memory AS sm USING(lir_id)
        LEFT JOIN per_worker_memory AS pwm USING(lir_id)
        JOIN
            mz_introspection.mz_mappable_objects AS mo
            ON (mlm.global_id = mo.global_id)
WHERE mo.name = 'materialize.public.v2_idx_x' AND pwm.worker_id = pwc.worker_id
ORDER BY mlm.lir_id DESC, worker_id;
EOF

# exhaustive "statement ok" checking

statement ok
EXPLAIN ANALYZE HINTS FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE CPU FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE CPU WITH SKEW FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE MEMORY FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE MEMORY WITH SKEW FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE CPU, MEMORY FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE MEMORY, CPU FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE CPU, MEMORY WITH SKEW FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE MEMORY, CPU WITH SKEW FOR MATERIALIZED VIEW w;

statement ok
EXPLAIN ANALYZE HINTS FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE CPU FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE CPU WITH SKEW FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE MEMORY FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE MEMORY WITH SKEW FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE CPU, MEMORY FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE MEMORY, CPU FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE CPU, MEMORY WITH SKEW FOR INDEX v_idx_x;

statement ok
EXPLAIN ANALYZE MEMORY, CPU WITH SKEW FOR INDEX v_idx_x;
